<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>fri3nds</title>
    <description>Here is my personal weblog about technology and life.</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 14 Jan 2017 03:38:20 +0800</pubDate>
    <lastBuildDate>Sat, 14 Jan 2017 03:38:20 +0800</lastBuildDate>
    <generator>Jekyll v3.3.1</generator>
    
      <item>
        <title>2016的一些总结</title>
        <description>&lt;h1 id=&quot;2016-年总结&quot;&gt;2016 年总结&lt;/h1&gt;

&lt;p&gt;2016 年总来的来说还是有所收获的吧。有很多可以说的，但是有觉得没什么营养。写不出高山，那就流水般地写着吧。&lt;/p&gt;

&lt;h2 id=&quot;coffeescript&quot;&gt;CoffeeScript&lt;/h2&gt;

&lt;p&gt;CoffeeScript 是工作以来，第一个 javascript 的方言吧，更多的是语法糖吧。coffee 可以让你在编写程序时，少入一些坑(由 javascript 语言本身导致的)，而且编写的代码少，兼容性好(因为 coffee 最好是编译成 es3 的)，开发效率高。我记得百度音乐的播放器应该是用 coffee 写的，Atom 编辑器也是用 coffee 写的。感兴趣的可以看看 spine 这个项目，你会发现 coffee 的代码原来可以写的这么优美。&lt;/p&gt;

&lt;p&gt;但是现在，已经慢慢地转到 es6 了，coffee 的很多语法糖，es6 也基本上实现了。毕竟 es 标准也是 js 的大趋势，还是不能逆势而为。github 上的库基本上也是 es6 的源码，不去看看 es6 的话，你看源码还真的是不习惯。&lt;/p&gt;

&lt;p&gt;今年 coffee2 应该出了吧，到时候第一时间去尝尝鲜，对 coffee 也是有一种情愫。&lt;/p&gt;

&lt;h2 id=&quot;webpack&quot;&gt;webpack&lt;/h2&gt;

&lt;p&gt;webpack 接触的还算是早吧，大概是 2015年9月份的样子。之前实习的时候，还有老项目用的是 ant，当时表示很吃惊。后面用 grunt、gulp、browserify，到后来的 webpack，了解过 rollup，但没有去使用过。现在平常都是用 webpack，有时候也用用 gulp。这些构建工具的优缺点，网上对比分析也是很多的。中间也有去尝试 happypack，但是它对很多 loader 的兼容性很差，实际项目中，也是很难使用。&lt;/p&gt;

&lt;h2 id=&quot;editor-vs-ide&quot;&gt;Editor VS IDE&lt;/h2&gt;

&lt;p&gt;说起编辑器或者是 IDE，我真的是折腾过不少。最开始的时候，用的是 Sublime Text，很漂亮，也很强大。后面又换成 WebStorm，真的是很强大，但是这个编辑器太重了，而且那一套快捷键真的习惯不了。后面就换成了 Atom，界面也很漂亮，就是插件多起来，启动很慢，而且编辑、保存的时候很卡。然后换成了 Vim，编辑器之神，自己也配置了很多插件，功能也很强大。后面换成了 Spacemacs，这个是基于 Emacs 做的一个编辑器，我承认我是被它的优美的界面吸引的。后来小试了一下 vscode，各方面都不错，就是界面有点丑。&lt;/p&gt;

&lt;p&gt;主要讲讲这些 Editor/IDE 的优缺点吧。&lt;/p&gt;

&lt;p&gt;Sublime Text：界面漂亮，快捷键设计的很好，不清楚的功能，有一个统一的入口，记住关键字就可以了，多使用几遍，快捷键就记住了。打开速度比较快，编辑、保存的速度很快。可以自己定义很多补全、常有代码块啊、自定义自己的snippet，也有多光标，编写效率也是杠杠的。插件也很齐全，唯一的缺点就是在卸载插件的时候，卸载不干净。&lt;/p&gt;

&lt;p&gt;Atom：号称新一代编辑器，确实不错，也是借鉴 ST 的有点吧，所有的功能都有一个统一的入口，我觉得这一点真的是现在编辑器必须要有的。Sublime Text 有的，它应该都有吧。缺点就是打开大文件，卡。打开大项目的时候，也是卡。弃用的主要原因。&lt;/p&gt;

&lt;p&gt;WebStorm：功能强大，自带版本管理工具。补全做的相当好，代码跳转，进入函数真的是很有用的。而且可以很方便地调试 node，很赞，就是太重。其他几个都只能说是 Editor，这个就是一个 IDE。&lt;/p&gt;

&lt;p&gt;Vim：编辑器之神。打开文件最快，编辑、保存都非常快。天下武功，为快不破。其几种模式，保证了 VIM 功能和效率的强大。默认是不支持多光标，但是有命令模式，还需要多光标吗?! 也有插件使其支持多光标，无非是 visual 而已。自定义 snippet，配置快捷键，快的飞起，游走于 buffer、window、tab 之中，完全不需要鼠标。缺点就是打开长行文件，比如压缩后的 js 代码。另外打开大文件的时候，一定要配置关闭高亮等其他非必须的功能，不然编辑、保存会卡。&lt;/p&gt;

&lt;p&gt;Spacemacs：其实就是美化后的 emacs(神之编辑器)。Vim 不要喷我，我是被外表吸引的，但是我还是用 Spacemacs 的 vim 模式编辑文件的。Emacs 不如 Vim 被广大程序员使用，可能更多的是因为其快捷键，真的是……😂。但是 Spacemacs 美化了 Emacs 的外表，对其快捷键进行了梳理，基本上不需要怎么记忆。另外就是使用了很强大的插件就 Vim 引入了 Emacs，简直就是屠龙倚天在手。为什么说 Emacs 是神之编辑器呢？我个人是觉得，是因为其功能强大吧。因为 Emacs 就是伪装成编辑器的操作系统，在 Emacs 中，你可以编辑、浏览网页、看电影、…&lt;/p&gt;

&lt;p&gt;VSCode：微软出品，必属精品(除了 Windows 操作系统)。毕竟一个软件公司，做一个编辑器对他们来说，小 case。打开文件速度慢于 Sublime Text，快于 Atom。代码补全很强大。编辑、保存很快。缺点就是快捷键不习惯、界面丑吧。&lt;/p&gt;

&lt;h2 id=&quot;functional-programming&quot;&gt;Functional Programming&lt;/h2&gt;

&lt;p&gt;打开我去了解函数式编程大门的就是 Redux，写 React 的都应该知道吧。&lt;/p&gt;

&lt;p&gt;高阶函数，可以让你对代码更加抽象。&lt;/p&gt;

&lt;p&gt;延时执行也是其一个特性。前几天还听到一句话，想快的话，先想慢，想想哪些是可以慢的，于是延时加载、异步加载等等优化手段就出来了。&lt;/p&gt;

&lt;p&gt;无副作用，函数式的编程，保证了相同的输入得到相当的输出，避免一些无法预知的问题。&lt;/p&gt;

&lt;p&gt;λ 演算，函数式编程的基础。函数式编程越来越被推崇，但是 λ 演算、Y 组合因子的作用倒不是很重要吧。但是在函数式编程中，很多时候是使用匿名函数的，那么这个时候 Y 组合因子的作用就体现出来了，我们需要递归条用这个匿名函数的时候怎么办。Y 组合因子就是来解决这个问题的。思路就是我们先假设这个匿名函数为 f，然后把这个匿名函数当参数传给一个函数，进行使用。Y 组合因子就是求解这个匿名函数以及调用关系的。具体地可以看看&lt;a href=&quot;http://cgnail.github.io/academic/lambda-1/&quot;&gt;这一系列的文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;react&quot;&gt;React&lt;/h2&gt;

&lt;p&gt;前端现在真的是百花齐放，目前大行其道的应该就是 React 和 Vue 吧。Vue 没有去尝试过，React 一直在用的，我们团队很早的时候就开始 React，并开始使用前后端同构的方式，同构的好处，网上有很多总结分析，此处就不罗嗦了，很明显的感觉就是首次加载的速度真的是快很多。&lt;/p&gt;

&lt;p&gt;说说我自己对 React 的一些浅显的想法吧。React 的思想，个人是觉得是采用了有限状态机的思路。之前学习《计算导论》的时候，觉得真的是很难，注意不是计算机导论，前者是计算机系统比较偏底层的一些理论，如何证明 NP 问题、NP-hard 问题；后者只是一些计算机入门的知识。&lt;/p&gt;

&lt;p&gt;在计算导论里面，讲到了有限状态机，状态机状态分析也是很复杂的。有兴趣的可以去网上找找资料。&lt;/p&gt;

&lt;p&gt;React 组建中 state 的变化就引发了状态变化，导致 UI 变化，采用申明式的编程，个人觉得带来的好处就是我们定义好每一种状态对应的情况，所有的变化都是引发相应的变化，使得程序更可控。组件化，又使得我们每个组件之关注自身 care 的状态，有效地降低了整个系统的复杂性，增加组建内部的聚合性。只依赖数据状态，也降低了组件间的耦合性。&lt;/p&gt;

&lt;p&gt;组件思想很很符合，生活中的哲学思想吧。就像一个大企业，老板不可能关系所有的事情，把不同的事情交给不同的主管，主管在把不同的员工去负责。父组件将不同的数据给不同的子组件，子组件再可以根据其实际情况进行拆分。小公司没有层级很深的等级划分是没有问题的，大公司人数众多，不划分根本是没有办法管理的。&lt;/p&gt;

&lt;p&gt;React 使得我们在编写程序时，不用关系组件 A对组件 B会造成什么影响。比如说，我们编写一个类似网易云音乐的播放软件时，一个标识歌曲是否播放的数据变量 isPlaying。碟盘转动的组件依赖 isPlaying 变量，true 就转动，false 就停止。歌词滚动播放的组件也依赖这个变量。当我们点击暂停键的时候，暂停键通过改变 isPlaying 的值，改变其状态，而依赖这个变量的组件就会更新其状态，进而更新其 UI，状态触发其行为。将组件中间的耦合性转化到对数据状态的耦合，组件在编写的时候，只需要考虑自己的依赖。&lt;/p&gt;

&lt;p&gt;如何不采用这种模式的化，可能就是暂停键点击了暂停时，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;碟盘转动组件&lt;/code&gt; 来暂停转动，调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;歌词组件&lt;/code&gt; 来暂停歌词的滚动。如果后面功能复杂起来，那么暂停键的业务会越来越复杂。&lt;/p&gt;

&lt;p&gt;当然还可以才用观察者模式，采用这种方式编写的化，会存在一个问题。就是事件的 bind 、unbind 以及事件的命名空间问题，因为当事件多了，必须采用命名空间来触发和屏蔽一些事件。本应该所有的变化依赖数据和状态，编程了都依赖于事件，而事件本身又传递数据，其实增加了组件和事件的耦合性。&lt;/p&gt;

&lt;p&gt;事件应该作为一个改变状态数据的方式和传递状态数据工具。事件去关系数据的变化，然后通知给其他组件。这样做的化，组件之和状态数据偶性，不用去和事件耦合了，不是更低的耦合性吗？！&lt;/p&gt;

&lt;h2 id=&quot;redux&quot;&gt;Redux&lt;/h2&gt;

&lt;p&gt;React 状态机思想，就牵扯到状态数据的流向。单向数据流慢慢地更多接受，因为单向数据流更简单。类似于计算系统中的系统总线吧。需要更新数据时，通过 Redux 的 action 去更新数据，数据通过总线然后告诉所有的组件。这样每个组件的数据来源就单一了，都是从所谓的 &lt;code class=&quot;highlighter-rouge&quot;&gt;总线&lt;/code&gt; 传递过来了，避免了各种 &lt;code class=&quot;highlighter-rouge&quot;&gt;私拉电线&lt;/code&gt; ，最后导致线路混乱的情形。&lt;/p&gt;

&lt;p&gt;每个组件的输入只有一个，不用 care 更多的东西，更加简单，也便于我们编写组件。统一了单向数据，也使得我们更容易使用别人的东西。你想想如果我们电脑上的某个元器件不仅仅依赖总线的数据，还依赖其他的元器件的输出，很可能你换了这个元器件就出现兼容性问题，不能通用。就像一个函数，不仅仅依赖函数参数，还依赖全局变量，那是多么奔溃的一件事。&lt;/p&gt;

&lt;p&gt;先写到这儿吧，以后有时间在随便扯扯。&lt;/p&gt;

&lt;p&gt;ps：非喜勿喷，欢迎指正、讨论。&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2017/01/09/2016%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2017/01/09/2016%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</guid>
        
        <category>javascript</category>
        
        
        <category>技术博文</category>
        
      </item>
    
      <item>
        <title>Mac 平台常用的一些工具、软件</title>
        <description>&lt;h1 id=&quot;mac-平台常用的一些工具软件&quot;&gt;Mac 平台常用的一些工具、软件&lt;/h1&gt;

&lt;p&gt;工欲善其事必先利其器，能够合理有效的利用工具，可以很大程度地提升工作效率。但是不能迷失在工具中，需使工具为我所用。&lt;/p&gt;

&lt;p&gt;我且将我平时所用的一些工具与君分享。我将这些工具分享为两类，某些工具既有 图形(GUI)工具，也有命令行(CLI) 工具，我会按照其主要的使用模式来分的。&lt;/p&gt;

&lt;h2 id=&quot;gui-工具&quot;&gt;GUI 工具&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.alfredapp.com/&quot;&gt;Alfred&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://www.alfredapp.com/media/pages/home/search.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;这个工具，应该是 Mac 平台下，首推的一个工具吧。随便 macOS 本身的不断升级优化，Alfred 的基本功能，已经慢慢地被 macOS 系统自带的 Spotlight 所替代。但是 Alfred 最为强大的应该是其 workflow。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Moom&lt;/p&gt;

    &lt;p&gt;Moom 是一个收费软件，是 OS X 上老牌的窗口管理应用，可以自定义自己的快捷键，最大化，分屏排列多个应用。&lt;/p&gt;

    &lt;p&gt;应用窗口排列如下图：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d161684gw1fbp2woimlqj21hc0u0k3n.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;你可以在它的设置里面，添加自己的排列方式，并为排列设置快捷键，如图所示；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d161684gw1fbp2yrtallj20d50hgwfq.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;它和其他某些窗口管理工具相比，比较优秀的一点的，Moom 作用在多个屏幕之间。&lt;/p&gt;

    &lt;p&gt;比如上图，我就将 &lt;code class=&quot;highlighter-rouge&quot;&gt;Move to other Display&lt;/code&gt; 设置成 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+o&lt;/code&gt;，这样我就可以用键盘就 chrome 移动我另外一个屏幕了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.iterm2.com/&quot;&gt;iTerm 2&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这个工具，比 macOS 系统下默认的 terminal 好用很多。你也可以用 homebrew cask 来安装 iTerm 的。iTerm 可以很方便地进行窗口、panel 的操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://bjango.com/mac/istatmenus/&quot;&gt;iStat Menus&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://bjango.com/images/mac/istatmenus5/header-cpu.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;iStat Menus 主要是用来现在一些系统状态信息，比如 cpu 状态、 电池状态、外网 ip 等等。很多时候，我只是有这个来看网速的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://macpaw.com/landings/land350?campaign=search_text_mobile_cmm3_brand_us&amp;amp;ci=350526486&amp;amp;adgroupid=23082375006&amp;amp;adpos=1t1&amp;amp;ck=cleanmymac2&amp;amp;targetid=kwd-48259207206&amp;amp;match=p&amp;amp;gnetwork=g&amp;amp;creative=155667511627&amp;amp;placement=&amp;amp;placecat=&amp;amp;accname=cmm&amp;amp;gclid=CjwKEAiAkuLDBRCRguCgvITww0YSJAAHrpf-Ogjw0bGtSI1Eyvz2Inu--RxiMoyXwexLOeNlqWGavRoCtVbw_wcB&quot;&gt;CleanMyMac 3&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://macpaw.com/img/landings/land217/screenshots/smart_cleanup.png&quot; alt=&quot;&quot; /&gt;这个软件类似 windows 上软件管家工具，卸载软件时，可以用到。清理系统磁盘文件时，还是很不错的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/us/app/movist/id461788075?mt=12&quot;&gt;Movist&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://a3.mzstatic.com/us/r30/Purple/v4/55/bc/9a/55bc9ab4-75b1-1cd9-0cab-88502c0e4752/screen800x500.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;OS X 自带的播放器很多编码格式都没有的，所以很多格式的视频是没有办法播放的。OS X 平台有很多优秀的视频播放软件，比如 VLC 等等啊，我也去试过，但是最后还是换成这个，因为这个确实很好用，拖拉进度条也是很快就响应的，而且而且这个还有一个老板键，一键静音。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;SourceTree&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw690/8d161684gw1fbp7ttx81mj20jg0c879g.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;用过 git 版本管理的，对 SourceTree 应该不陌生的。它是 git 一个跨平台的 GUI 工具。界面很不错，而且功能也是很强大的。我个人平时是使用 git 命令行居多，但是有时会 SourceTree 配合使用的。SourceTree 支持命令行的，比如在你在你的 repo 路径下，调用其命令行，则可以打开其 GUI。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://typora.io/&quot;&gt;Typora&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d161684gw1fbp87gaw1uj217o10ewix.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;这个是一个 MarkDown 软件。有很多 MarkDown 的软件，比如 Mou、MacDown、MWeb 等等，为什么我推荐这个软件，因为这个软件不像其他一个，他不想 Mou 那样一边是你的编辑的源码，一遍是预览。他就一种模式，更加让你专业于编写，你写了就立即看到。当你把光标移动到标题、图片之类的所在行时，它进入源码模式，这样你可以看到你定的几级标题，另外在每段回车的时候，它会自动段后加空行的，帮你省略了很多容易出错的操作。&lt;/p&gt;

    &lt;p&gt;另外它支持了很多主题，比如说 &lt;code class=&quot;highlighter-rouge&quot;&gt;github&lt;/code&gt; 的主题，还有其他的一些主题，比如你在夜晚的时候编写文稿时，可以选一种 dark 主题，让你更专注于编辑本身。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;Charles&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d161684gw1fbp8isxlitj20uk04qq3q.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;这是 OS 平台的一个抓包工具，很多前端程序员、Android/iOS 程序员应该都很熟悉，功能很强大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://itunes.apple.com/cn/app/id418073146&quot;&gt;snap&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这是一个 OS 全局快捷键的工具，可以给你常用的 app 设置一个全局快捷键。这样你就可以随便切换你的应用程序了，非常实用。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d161684gw1fbpc6d2vm9j20bt0bddg7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://kapeli.com/dash&quot;&gt;Dash&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://kapeli.com/img/dash-s1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Dash 是一个 API 文档管理和 Code Snippet 管理工具，可以配合你的编辑器使用，现在很多编辑器其实都有 Dash 插件，比如在你编写 node 代码时，你忘记了一个 fs 模块的一个方法的参数是什么时候，你可以在编辑器唤起 Dash 查看这个方法的文档。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Editor(IDE)&lt;/p&gt;

    &lt;p&gt;我个人尝试过很多编辑器，最开始的 Sublime Text、Atom、WebStrom、Vim、Spacemacs、VSCode。现在主要是使用 Spacemacs。每个编辑器都有自己的特点，都有自己擅长的东西。用什么编辑器看个人喜好了。&lt;/p&gt;

    &lt;p&gt;个人觉得一个编辑器，至少得保证三点，才能称上一个合理的编辑器。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;插件管理&lt;/li&gt;
      &lt;li&gt;代码补全&lt;/li&gt;
      &lt;li&gt;代码缩进、着色、主题配置等&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;a href=&quot;https://www.sublimetext.com/&quot;&gt;Sublime Text&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这个应该是现代编辑器的看上鼻祖吧。其优美的界面，合理的快捷键，强大的功能，退出之后就俘获了一大批程序员的芳心。
 ​&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d161684gw1fbp8xe2i7oj21fq0temzv.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;它的打开速度，编辑、保存的速度都是很快，很不错的。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://github-atom-io-herokuapp-com.global.ssl.fastly.net/assets/screenshot-main-80d8c9841da6ed11c9d87f31136a4ca9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Atom 是一个你可以完全自定义 UI 的编辑器，你可以对编辑器任何部分进行改造。&lt;/p&gt;

    &lt;p&gt;Vim/MacVim&lt;/p&gt;

    &lt;p&gt;传说中的编辑器之神，Vim 的强大编辑功能使得编辑的效率很快。但是 Vim 在编辑长行文件的时候，打开是很慢的。而且在打开大文件的时候，可以关闭其代码着色的。打开和编辑的速度回有很大的提升。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VSCode&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://code.visualstudio.com/home/home-screenshot-mac-lg.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;VSCode 功能很强大，可以在其调试 node 代码，js 的编辑器应该只有 VSCode 和 WebStorm 两个默认支持的。其打开、编辑速度都很快，而且其代码补全也是很强大的。&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/syl20bnr/spacemacs&quot;&gt;Spacemacs&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://spacemacs.org/doc/img/spacemacs-python.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;其实就是美化后的 emacs(神之编辑器)。Vim 不要喷我，我是被外表吸引的，但是我还是用 Spacemacs 的 vim 模式编辑文件的。Emacs 不如 Vim 被广大程序员使用，可能更多的是因为其快捷键，真的是……😂。但是 Spacemacs 美化了 Emacs 的外表，对其快捷键进行了梳理，基本上不需要怎么记忆。另外就是使用了很强大的插件就 Vim 引入了 Emacs，简直就是屠龙倚天在手。为什么说 Emacs 是神之编辑器呢？我个人是觉得，是因为其功能强大吧。因为 Emacs 就是伪装成编辑器的操作系统，在 Emacs 中，你可以编辑、浏览网页、看电影、…&lt;/p&gt;

    &lt;p&gt;我个人现在在使用 Spacemacs 作为主力编辑器，很多单个文件的打开，可能跟多的选择 VSCode 打开。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;cli-工具&quot;&gt;CLI 工具&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;http://brew.sh/&quot;&gt;homebrew&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw690/8d161684gw1fboz3eai6dj2074074q33.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;homebrew 是 Mac 平台下一个包管理工具，类似于 centOS 的 yum，Ubuntu 下的 apt-get。这个应该是 Mac 平台下第一安装 CLI 吧。  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://caskroom.github.io/&quot;&gt;homebrew cask&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;homebrew 主要是用来安装一些 cli 的，比如安装 node、java、wget、htop 等，而 homebrew cask 则是提供的是用 &lt;code class=&quot;highlighter-rouge&quot;&gt;命令来安装 GUI 软件&lt;/code&gt;，比如可以用 homebrew cask 安装 qq musci、chrome、Sublime Text 等。  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/tmux/tmux&quot;&gt;tmux&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;为什么有了 iTrem2，还要使用 tmux 呢？二者的定位其实不是一样的，iTerm2 是一个 terminal 的终端，而 tmux 是一个 terminal multiplexer。&lt;/p&gt;

    &lt;p&gt;主要是 terminal 窗口的切换。其实很运维工程师都是喜欢用这个的，作为一个前端工程师可能就不需要了。但是我想说的是，很多时候你是需要的，应该很多时候，你在开发过程中，你是需要跑一些自动化工具的脚本，如果你是用 git 命令行的话，那你很多时候合并代码，diff 代码，可能需要开很多 terminal 窗口的，当你开的窗口很多的时候，仅仅依靠 iTerm 上的 title 来找之前的 terminal 的话会不够直接的。&lt;/p&gt;

    &lt;p&gt;而 tmux 中，你可以为一系列相关的操作新建一个 session&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw690/8d161684gw1fbpcq1d1dej21fq0t7413.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;你可以很方便地根据你的 session 名字在不同的 terminal 之间切换。&lt;/p&gt;

    &lt;p&gt;在每一个 session 中可以建多个 window，在每个 window 你有可以建多个 panel。每个 session、window 都可以命令，这样你可以根据命名快速切换。&lt;/p&gt;

    &lt;p&gt;最主要的 session 可以保存的，即使你退出 tmux 了，你下次也可以在进入之前的 session 的。&lt;/p&gt;

    &lt;p&gt;github 上有很多大牛的 tmux 配置文件，个人推荐 &lt;a href=&quot;https://github.com/gpakosz&quot;&gt;gpakosz&lt;/a&gt; 的配置。   ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/creationix/nvm&quot;&gt;nvm&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;nvm 即 Node Version Manager，用来管理你的 node 版本的。前端工程师应该是经常使用的。   ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/yyuu/pyenv&quot;&gt;pyenv&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;python 的一个版本管理工具。   ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/so-fancy/diff-so-fancy&quot;&gt;diff-so-fancy&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;git diff 时的一个美化工具。   ​&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d161684gw1fbpcdutthuj21fq0t7n6t.jpg&quot; alt=&quot;&quot; /&gt;   ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/nvie/gitflow&quot;&gt;git-flow&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;git-flow 是一个 git 扩展集，按 Vincent Driessen 的分支模型提供高层次的库操作。git-flow 是一个基于归并的解决方案，它并没有提供重置(rebase)特性分支的能力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://hisham.hm/htop/&quot;&gt;htop&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;Unix/Linux 系统下，一个交互式的进程查看工具。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/ggreer/the_silver_searcher&quot;&gt;ag&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;一个搜索工具，类似于 ack、grep，但是其速度极快。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/reorx/httpstat&quot;&gt;httpstat&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;一个可视化的 curl 命令行工具，这个工具有 go 和 python 版本的，我选择的是 python 版本的，因为 OS 系统自带 python 的，这样就不需要配置 go 环境了。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/8d161684gw1fbpj3wg0noj20pb0d30uk.jpg&quot; alt=&quot;&quot; /&gt;
​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/rofl0r/proxychains-ng&quot;&gt;proxychains-ng&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;terminal 的代理工具。  ​&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://github.com/rgcr/m-cli&quot;&gt;m-cli&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;OS X 系统的一些常用的 cli，你可以在命令行里，调节电脑音量、清理垃圾箱、查看磁盘等等。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h5 id=&quot;ps还有很多很有用的工具软件的希望大家补充&quot;&gt;PS：还有很多很有用的工具、软件的，希望大家补充。&lt;/h5&gt;

</description>
        <pubDate>Mon, 09 Jan 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2017/01/09/2016-Mac-%E5%B9%B3%E5%8F%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2017/01/09/2016-Mac-%E5%B9%B3%E5%8F%B0%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B7%A5%E5%85%B7-%E8%BD%AF%E4%BB%B6/</guid>
        
        <category>cli software</category>
        
        
        <category>技术博文</category>
        
      </item>
    
      <item>
        <title>异次元杀阵之最大子段和的破解之法</title>
        <description>&lt;h3 id=&quot;1-前言&quot;&gt;1. 前言&lt;/h3&gt;
&lt;p&gt;首先解释一下这个标题。&lt;/p&gt;

&lt;p&gt;最近看了一个关于密室的系列电影，共有三部，个人只觉得第一部比价好看(ps:第三部还没有看)，它有两个名字，一个叫《心慌方》，比较文艺；两一个也叫《心慌方》，当然不可能了，其实是《异次元杀阵》，这个听上去比较科技感强一点。&lt;/p&gt;

&lt;p&gt;最大子段和，也叫&lt;code class=&quot;highlighter-rouge&quot;&gt;最大连续子数列和&lt;/code&gt;,AC圈都是这么叫的吧。我个人喜欢前面一个。最近也是看到有博主也写关于这个问题的算法，所以自己也想提笔试着写写(非喜勿喷)。关于&lt;code class=&quot;highlighter-rouge&quot;&gt;最大连续子数列和&lt;/code&gt;的解释可以看 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98&quot;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;为什么把两者扯到一起，因为我下面要讲的是解决这个问题的过程，如何演化！&lt;/p&gt;

&lt;h3 id=&quot;2-坐标&quot;&gt;2. 坐标&lt;/h3&gt;
&lt;p&gt;最容易想到的方法就是枚举，所以的情况都枚举出来，比较一下大小就可以了。&lt;/p&gt;

&lt;p&gt;以数组&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; A = [-2, 11, -4, 13, -5, -2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;为例。&lt;/p&gt;

&lt;p&gt;关于如何枚举，我个人容易想到的是2种；&lt;/p&gt;
&lt;h5 id=&quot;1-按子序列的长度枚举&quot;&gt;(1) 按子序列的长度枚举&lt;/h5&gt;
&lt;h5 id=&quot;2-按子序列的起点终点枚举&quot;&gt;(2) 按子序列的起点、终点枚举&lt;/h5&gt;
&lt;p&gt;二者其实是一样的，知道起始点就知道长度了，只是第二种记录起始点听上去顺理成章一点。本质上时间复杂度都是&lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^3)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解法1&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var A = [-2, 11, -4, 13, -5, -2];
var ans = A[0];
var s;

for(var n = 1; n &amp;lt;= A.length; n++) {
  for(var i = 0; i &amp;lt; A.length; i++) {
    s = 0;
    for(var j = 0; j &amp;lt; n; j++) {
      s += A[i+j];
    }
    if (s &amp;gt; ans) {
      ans = s;
    }
  }
}

console.log(ans, '=========');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;解法2&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var A = [-2, 11, -4, 13, -5, -2];
var ans = A[0];
var s;

for(var i = 0; i &amp;lt; A.length; i++) {
  for(var j = i; j &amp;lt; A.length; j++) {
    s = 0;
    for(var k = i; k &amp;lt;= j ; k++) {
      s += A[k];
    }
    if (s &amp;gt; ans) {
      ans = s;
    }
  }
}

console.log(ans, '=========');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两中方法其实都是通过记录起始点的手段来来解决问题，也就是记录&lt;code class=&quot;highlighter-rouge&quot;&gt;坐标&lt;/code&gt;，有点像《心慌方》中理科女，通过坐标来辨识安全的房间.
(在更新 ans 的时候，可以记录相应的起始点，就得到我们想要的&lt;code class=&quot;highlighter-rouge&quot;&gt;坐标&lt;/code&gt;了)&lt;/p&gt;

&lt;p&gt;两种枚举的方法都其实是引入了两个变量，在解决很多数学问题上，一些问题通过&lt;code class=&quot;highlighter-rouge&quot;&gt;消元&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;降次&lt;/code&gt;基本上可以解决了。
这种思路也适用于算法设计。
此外，计算机很多的问题都是&lt;code class=&quot;highlighter-rouge&quot;&gt;量&lt;/code&gt;导致的，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;量&lt;/code&gt;很小的话，问题很容易解决。&lt;/p&gt;

&lt;p&gt;仔细观察 &lt;code class=&quot;highlighter-rouge&quot;&gt;解法2&lt;/code&gt; 可以发现，我们很多次循环都是在求解 A[i…j] 的累加和，如何避免这种重复的劳动了，
在计算机上面，可以使用另外一种优化手段，&lt;code class=&quot;highlighter-rouge&quot;&gt;空间换时间&lt;/code&gt; ，当然也存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;时间换空间&lt;/code&gt; 的&lt;/p&gt;

&lt;p&gt;由此可以引申出 3 种优化思路：&lt;/p&gt;
&lt;h5 id=&quot;1-空间换时间&quot;&gt;(1) &lt;code class=&quot;highlighter-rouge&quot;&gt;空间换时间&lt;/code&gt;&lt;/h5&gt;
&lt;h5 id=&quot;2-通过降量-来优化这个问题的解计算机&quot;&gt;(2) 通过降”量” 来优化这个问题的解(计算机)&lt;/h5&gt;
&lt;h5 id=&quot;3-通过-消元-或者-降次-来优化这个问题的解数学&quot;&gt;(3) 通过 “消元” 或者 “降次” 来优化这个问题的解(数学)&lt;/h5&gt;

&lt;h3 id=&quot;3-备忘录&quot;&gt;3. 备忘录&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;解法2&lt;/code&gt; 中多次求解 A[i…j] 的累加和，如果能够花费一些空间把它记录下来，不就是省掉一层循环了，降低了时间复杂度；
实际上很多问题都可以通过备忘录，来省去重复的工作。&lt;/p&gt;

&lt;p&gt;如果用 sum[i] 表示 A 中 A[0] 到 A[i] 的累加和，那么 A[i..j] = sum[j] - sum[i-1];
我们在外层计算出数组 sum，记录下来，在需要用到 A[i…j] 的时候，通过简单的减法运算就可以实现了，减少了一层循环，时间复杂度就降低到 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
var A = [-2, 11, -4, 13, -5, -2];
var sum = [];
sum[0] = A[0];
var ans = A[0];
var s;

for(var i = 1; i &amp;lt; A.length; i++) {
  sum[i] = sum[i-1] + A[i];
}
for(i = 1; i &amp;lt; A.length; i++) {
  for(var j = i; j &amp;lt; A.length; j++) {
    s = sum[j] - sum[i-1];
    if (s &amp;gt; ans) {
      ans = s;
    }
  }
}

console.log(ans, '=========');

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4-降-量&quot;&gt;4. 降 “量”&lt;/h3&gt;
&lt;p&gt;尝试了第一种优化方式，确实得到了一些优化，那继续尝试第二种咯。&lt;/p&gt;

&lt;p&gt;一般在很多问题的处理上，都是通过降 “量” 来优化，比如预先排除一些没有用的数据，来降低数据的量级。而我们这个问题是没有办法
直接通过预先处理、筛选一些数据解决的。&lt;/p&gt;

&lt;p&gt;但是最大子段和问题，我们可以换一种方式来理解降 “量”。&lt;/p&gt;

&lt;p&gt;如果整个序列只有 1 个或者 2 个元素，问题是不是简单很多。我们解决只有 1 个元素的序列的最大子段和问题，那么就可以解决只有 2 个
元素的最大子段和，进而 4 个、8 个，……&lt;/p&gt;

&lt;p&gt;是不是突然感觉有点熟悉，&lt;code class=&quot;highlighter-rouge&quot;&gt;分治&lt;/code&gt; 感觉已经呼之欲出了。对，就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;分而治之&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;求解整个序列的最大子段和，我们可以分解成两部分:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;求左半部分的最大子段和，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;求右半部分的最大子段和，&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据左、右两个半部分的最大子段和，求解整个序列的最大子段&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;求解左、右半部分的最大字段和最后都可以分解成 “只有 1 个元素的序列的最大子段和问题”，这大概就是&lt;code class=&quot;highlighter-rouge&quot;&gt;一个小目标&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;那么 “只有 2 个元素的序列的最大子段和问题” 可以通过上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;小目标&lt;/code&gt;来实现。如果左半部分的最大子段和是 0，那整个序列的最大子段和就在右半部分；如果右半部分的最大子段和是 0，那整个序列的最大子段和就在左半部分；(如果左右都为 0，上述那个如果都满足，依旧是 0)
剩余的情况就是整个序列的最大子段和由 &lt;code class=&quot;highlighter-rouge&quot;&gt;左半部分的最大子段和&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;右半部分的最大字段和&lt;/code&gt; 共同组成。&lt;/p&gt;

&lt;p&gt;这其实就是&lt;code class=&quot;highlighter-rouge&quot;&gt;分治&lt;/code&gt;问题的核心，如何由小的问题汇总大的问题，怎么由&lt;code class=&quot;highlighter-rouge&quot;&gt;先赚它一个亿&lt;/code&gt;到成为&lt;code class=&quot;highlighter-rouge&quot;&gt;首富&lt;/code&gt;的问题。&lt;/p&gt;

&lt;p&gt;具体问题具体分析，最大子段和，也叫最大连续子数列和。关键词是连续。
于是这个问题就是最大连续子序列和要么出现在数组左半部分，要么出现在数组右半部分，要么横跨左右两半部分。横跨左右两半部分就受到连续这个关键词的限制。&lt;/p&gt;

&lt;p&gt;具体解法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var A = [-2, 11, -4, 13, -5, -2];
function MaxSubSequence(left, right) {
  if (left &amp;gt; right) {
    return 0;
  }
  // 只有 1 个元素的序列
  if (left === right) {
    return A[left];
  }

  // 划分为 “左半部分的最大子段和” 和 &quot;右半部分的最大子段和&quot;
  var mid = (left + right) / 2;
  mid &amp;gt;&amp;gt;&amp;gt;= 0;
  var leftMaxSubSequence = MaxSubSequence(left, mid);
  var rightMaxSubSequence = MaxSubSequence(mid + 1, right);

  // 求横跨左右的最大连续子序列左半部分
  var lmax = A[mid], lsum = 0;
  for(var i = mid; i &amp;gt;= left; i--) {
    lsum += A[i];
    if (lsum &amp;gt; lmax) {
      lmax = lsum;
    }
  }

  // 求横跨左右的最大连续子序列右半部分
  var rmax = A[mid + 1], rsum = 0;
  for(var j = mid + 1; j &amp;lt;= right; j++) {
    rsum += A[j];
    if (rsum &amp;gt; rmax) {
      rmax = rsum;
    }
  }
  return Math.max(lmax + rmax, leftMaxSubSequence, rightMaxSubSequence); //返回三者最大值
}

var ans = MaxSubSequence(0, A.length - 1);
console.log(ans, '===============');

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整个解法的时间复杂度是 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n*lgn)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其实我们，可以看到解决这个问题的过程中，我们实际上还是依赖于两个变量，left 和 right，并没有&lt;code class=&quot;highlighter-rouge&quot;&gt;消元&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接下来，我们试试&lt;code class=&quot;highlighter-rouge&quot;&gt;消元&lt;/code&gt;吧。&lt;/p&gt;

&lt;h3 id=&quot;5-消元&quot;&gt;5. 消元&lt;/h3&gt;
&lt;p&gt;前面的两种优化手段依旧和&lt;code class=&quot;highlighter-rouge&quot;&gt;坐标&lt;/code&gt;有关系，还是二元，我们尝试一下消元。&lt;/p&gt;

&lt;p&gt;一直停留在最大连续子数列和起点和终点上，一直不能愉快地消元，实际这个问题，不管原序列有多少个元素，都有起点和终点，但是
如果只有 1 个元素的话，是不是起点和终点重合，如果原序列很长，就是终点很远，但是起点还是起点，不管原序列多长，变化一直是终点，
所以可不可以不关心起点，只 care 我们的终点，把起点这个&lt;code class=&quot;highlighter-rouge&quot;&gt;元&lt;/code&gt;消除掉。&lt;/p&gt;

&lt;p&gt;ok，于是我们假设 max[j] 是 序列 A[0…j] 的最大字段和。能不能通过类似数学归纳法来求得一个递推公式呢？！&lt;/p&gt;

&lt;p&gt;我们需要解决的就是如何从 max[j] 求出 max[j+1] 的值。&lt;/p&gt;

&lt;p&gt;最大连续子数列和，其中关键就是连续。 
从 max[j] 到 max[j+1] ，考虑连续与否就可以了。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;a. max[j] 的终点是 A[j]
b. max[j] 的终点不是 A[j]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;a-maxj-的终点是-aj&quot;&gt;a. max[j] 的终点是 A[j]&lt;/h4&gt;
&lt;p&gt;那么 max[j+1] = Max(max[j-1], max[j-1] + A[j])&lt;/p&gt;
&lt;h4 id=&quot;b-maxj-的终点不是-aj&quot;&gt;b. max[j] 的终点不是 A[j]&lt;/h4&gt;
&lt;p&gt;假设 max[j] 的终点是 A[m]
那么 max[j+1] = Max(max[j-1], max[j-1] + (A[m+1] + A[m+2] + … + A[j]) )&lt;/p&gt;

&lt;p&gt;综上，在递推的过程中我们记录终点 m 就可以了.&lt;/p&gt;

&lt;p&gt;所以在遍历的 j 的时候，记录更新 m 就可以了。而记录终点 m 也是为了求 (A[m+1] + A[m+2] + … + A[j])，
tmp 记录 A[m+1] 到 A[j-1] 的累积和&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果 tmp + A[j] + max[j-1] &amp;gt; max[j-1] ，max[j] = max[j-1] + tmp + A[j], tmp 也相应地更新为 0；
如果 tmp + A[j] + max[j-1] &amp;lt;= max[j-1] ，max[j] = max[j-1], tmp 也相应地更新为 tmp + A[j]；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;具体解法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var A = [-2, 11, -4, 13, -5, -2];
var ans = 0;
var tmp = 0; // 记录 A[m+1] + A[m+2] + ... + A[j-1]

for(var j = 0; j &amp;lt; A.length; j++) {
  if (tmp + A[j] &amp;gt; 0) {
    ans += A[j] + tmp;
    tmp = 0;
  } else {
    if (j != 0 ) { // 处理序列第一个元素 A[0] &amp;lt; 0
      tmp += A[j];
    }
  }
}

console.log(ans, '=========');

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;该解法的时间复杂度为 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-降维&quot;&gt;6. 降维&lt;/h3&gt;

&lt;p&gt;降维，通过低维打击高维，才是王道。上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n)&lt;/code&gt; 算法中，&lt;code class=&quot;highlighter-rouge&quot;&gt;max[]&lt;/code&gt; 只需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;max[j]&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;max[j-1]&lt;/code&gt;，所以可以用一个变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;ans&lt;/code&gt; 即可解决问题。 在很多动态规划的算法中，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;降维&lt;/code&gt;来实现空间复杂度的优化， 例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j] = Max(dp[i-1][j], dp[i][j-1])&lt;/code&gt; 之类的， 数组 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[][]&lt;/code&gt; 只用到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1]&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i]&lt;/code&gt;，我们完全可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;dpmin[]&lt;/code&gt; 来取代 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[][]&lt;/code&gt;，优化空间复杂度。&lt;/p&gt;

&lt;p&gt;还有一些动态规划的问题中，例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i][j] = Max(∑dp[i-1][n](0&amp;lt;=n&amp;lt;j)*A[i][j], A[i][j])&lt;/code&gt; 之类的， &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i]&lt;/code&gt; 的状态与整个 &lt;code class=&quot;highlighter-rouge&quot;&gt;dp[i-1]&lt;/code&gt; 数组都有关系的时候， 我们也可以用过 &lt;code class=&quot;highlighter-rouge&quot;&gt;b[j] = Max(∑a[n](0&amp;lt;=n&amp;lt;j)*A[i][j], A[i][j]); a[] = b[]&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;a[]&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;b[]&lt;/code&gt; 做一个交换来优化空间复杂度，当然这样每次交换也牺牲了一部分的效率。&lt;/p&gt;

&lt;h3 id=&quot;扩展&quot;&gt;扩展&lt;/h3&gt;
&lt;p&gt;文章提到的一些解法和优化方法，实际上被大神设计出来，掌握这些最本质的东西，在解决实际问题的时候，有一个渐进式思维，擅用算法，逐步优化，我觉得才是异次元方阵的破解之法。
如果您感兴趣的话，也可以去了解&lt;code class=&quot;highlighter-rouge&quot;&gt;动态规划&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;分治&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;备忘录&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;最大连续子矩阵和&lt;/code&gt; 等。我后续也会慢慢去介绍相关的东西。&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Sep 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/09/25/%E5%BC%82%E6%AC%A1%E5%85%83%E6%9D%80%E9%98%B5%E4%B9%8B%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E7%A0%B4%E8%A7%A3%E4%B9%8B%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/09/25/%E5%BC%82%E6%AC%A1%E5%85%83%E6%9D%80%E9%98%B5%E4%B9%8B%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%E7%9A%84%E7%A0%B4%E8%A7%A3%E4%B9%8B%E6%B3%95/</guid>
        
        <category>算法</category>
        
        
        <category>技术博文</category>
        
      </item>
    
      <item>
        <title>GET和POST有什么区别？及为什么网上的多数答案都是错的。</title>
        <description>&lt;p&gt;初看到这篇文章的时候，觉得标题又是一个噱头。因为技术圈很多时候也有点像娱乐圈，很多人都只是为了搏眼球。但是闲来无聊就看了一下。看了一点就觉得被打脸了。原文作者文章写的确实很不错。故此在这儿转发，以表敬意。&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;如果有人问你，GET 和 POST，有什么区别？你会如何回答？&lt;/p&gt;
  &lt;h4 id=&quot;我的回答&quot;&gt;我的回答&lt;/h4&gt;
  &lt;p&gt;前几天有人问我这个问题。我说 GET 是用于获取数据的，POST，一般用于将数据发给服务器之用。&lt;/p&gt;

  &lt;p&gt;这个答案好像并不是他想要的。于是他继续追问有没有别的区别？我说这就是个名字而已，如果服务器支持，他完全可以把 GET 改个名字叫 GET2。他反问道，那就是单纯的名字上的区别喽？我想了想，我觉得如果说再具体的区别，只能去看 RFC 文档了，还要取决于服务器（指 Apache，IIS）的具体实现。但我不得不承认，我的确没有仔细看过 HTTP 的 RFC 文档。于是我说，我对 HTTP 协议不太熟悉。这个问题也就结束了。&lt;/p&gt;

  &lt;h4 id=&quot;最普遍的答案&quot;&gt;最普遍的答案&lt;/h4&gt;

  &lt;p&gt;回来之后寻思了很久，他到底是想问我什么？我一直就觉得 GET 和 POST 没有什么除了语义之外的区别，自打我开始学习 Web 编程开始就是这么理解的。&lt;/p&gt;

  &lt;p&gt;可能很多人都已经猜到了，他要的答案是：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;GET使用 URL 或 Cookie 传参。而 POST 将数据放在 BODY 中。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;GET 的 URL 会有长度上的限制，则 POST 的数据则可以非常大。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;POST 比 GET 安全，因为数据在地址栏上不可见。&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;但是很不幸，这些区别全是错误的，更不幸的是，这个答案还是 &lt;a href=&quot;https://www.google.com.hk/search?q=get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB&amp;amp;ie=utf-8&amp;amp;oe=utf-8&amp;amp;aq=t&amp;amp;rls=org.mozilla:zh-CN:official&amp;amp;client=firefox-a&amp;amp;channel=fflb&amp;amp;gws_rd=cr,ssl&quot;&gt;Google搜索的头版头条&lt;/a&gt;，然而我根本没想着这些是答案，因为在我看来他们都是错的。我来一一解释一下。&lt;/p&gt;

  &lt;h4 id=&quot;get-和-post-与数据如何传递没有关系&quot;&gt;GET 和 POST 与数据如何传递没有关系&lt;/h4&gt;

  &lt;p&gt;GET 和 POST 是由&lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616.html&quot;&gt;HTTP协议&lt;/a&gt;定义的。在 HTTP 协议中，Method 和 Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个 Method 与应用层的数据如何传输是没有相互关系的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个如果你自己有过实际的尝试，就会完全同意原作者的。
博主在开发中就深有体会，我们没有用一些 ajax 的库，而是自己基于 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;fetch api&lt;/a&gt; 和 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt; 封装了自己的一个名为 WebAPIUtils 的网络请求库，其中默认根据参数 body 是否为空对象，来确定 GET 或者是 POST 请求，当然你也可以指定 Method。发现原来 GET 或者是 POST 和 body 是没有关系的。只是我们一般都是这么理解的，一直是很模凌两可。(好，我们继续原作者的文章)&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;HTTP 没有要求，如果 Method 是 POST 数据就要放在 BODY 中。也没有要求，如果Method 是 GET，数据（参数）就一定要放在 URL 中而不能放在 BODY 中。&lt;/p&gt;

  &lt;p&gt;那么，网上流传甚广的这个说法是从何而来的呢？我在 &lt;a href=&quot;https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13.1&quot;&gt;HTML标准中，找到了相似的描述&lt;/a&gt;。这和网上流传的说法一致。但是这只是 HTML 标准对 HTTP 协议的用法的约定。怎么能当成 GET 和 POST 的区别呢？&lt;/p&gt;

  &lt;p&gt;而且，现代的 Web Server 都是支持 GET 中包含 BODY 这样的请求。虽然这种请求不可能从浏览器发出，但是现在的 Web Server 又不是只给浏览器用，已经完全地超出了 HTML 服务器的范畴了。&lt;/p&gt;

  &lt;p&gt;知道这个有什么用？我不想解释了，有时候就得自己痛一次才记得住。&lt;/p&gt;

  &lt;h4 id=&quot;http-协议对-get-和-post-都没有对长度的限制&quot;&gt;HTTP 协议对 GET 和 POST 都没有对长度的限制&lt;/h4&gt;

  &lt;p&gt;HTTP 协议明确地指出了，HTTP 头和 Body 都没有长度的要求。而对于 URL 长度上的限制，有两方面的原因造成：&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;浏览器。据说早期的浏览器会对 URL 长度做限制。据说 IE 对 URL 长度会限制在 2048 个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了 90K 的 URL 通过 IE9 访问 live.com，是正常的。网上的东西，哪怕是 Wikipedia 上的，也不能信。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;服务器。URL 长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几 M 大小的 URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器 Content-Length 是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给 URL 长度加限制。但是这个限制是针对所有 HTTP 请求的，与 GET、POST 没有关系。&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;

  &lt;h4 id=&quot;安全不安全和-getpost-没有关系&quot;&gt;安全不安全和 GET、POST 没有关系&lt;/h4&gt;

  &lt;p&gt;我觉得这真是中国特色。我讲个小段子，大家应该可以体会出这个说法多么的可笑。&lt;/p&gt;

  &lt;p&gt;觉得 POST 数据比 GET 数据安全的人会说&lt;/p&gt;

  &lt;p&gt;“防君子不防小人；中国小白多，能防小白用户就行了。”&lt;/p&gt;

  &lt;p&gt;“哼，”我不以为然，“那你怎么不说，URL 参数都 Encode 过了，或是 Base64 一下，小白也看不懂啊。”&lt;/p&gt;

  &lt;p&gt;那人反驳道，“Encode 太简单了，聪明点儿的小白很容易就可以 Decode 并修改掉。”&lt;/p&gt;

  &lt;p&gt;我笑道，“五十步笑百步耳，再聪明点儿的小白还会截包并重发呢，Opera 就有这功能。”&lt;/p&gt;

  &lt;p&gt;那人阴险地祭出神器——最终解释权，说，“这个不算小白。”&lt;/p&gt;

  &lt;p&gt;我日啊。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;网络安全其实就是这样的，不过你用 GET 和 POST 都是然并卵。调试工具一打开，你往那个地址发送了什么东西全都可以看的见。如果在被截包，简直就是没有穿衣服啊。&lt;/p&gt;

&lt;blockquote&gt;

  &lt;p&gt;最后一点儿感想&lt;/p&gt;

  &lt;p&gt;我之前一直做 Windows 桌面应用，对 Web 开发无甚了解，直到一年多前转做服务器端开发，才开始接触到 HTTP。（注意，我说的是 HTTP，不是 HTML 。服务器开放接口是基于 REST 理念设计的，使用的协议是H TTP，但是传输的内容不是 HTML。这不是 Web Server，而是一个 Web Service）&lt;/p&gt;

  &lt;p&gt;所以我对于 GET 和 POST 的理解，是纯粹地来源于 HTTP 协议。他们只有一点根本区别，简单点儿说，一个用于获取数据，一个用于修改数据。具体的请参考 RFC 文档。&lt;/p&gt;

  &lt;p&gt;如果一个人一开始就做 Web 开发，很可能把 HTML 对 HTTP 协议的使用方式，当成 HTTP 协议的唯一的合理使用方式。从而犯了以偏概全的错误。&lt;/p&gt;

  &lt;p&gt;可能有人会觉得我钻牛角尖。我只是不喜欢模棱两可，不喜欢边界不清、概念不明，不喜欢“拿来主义”，也不喜欢被其它喜欢钻牛角尖的人奚落得无地自容。&lt;/p&gt;

  &lt;p&gt;“知之为知之，不知为不知，是知也。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;感想&quot;&gt;感想&lt;/h4&gt;
&lt;p&gt;首先，感谢原作者分享这篇博文。其次，很敬佩原作者这种精神。&lt;/p&gt;

&lt;h4 id=&quot;安全问题&quot;&gt;安全问题&lt;/h4&gt;
&lt;p&gt;web 应用的安全问题不能靠 GET 和 POST 简单地解决的。后续文章会讲讲 web 应用的安全问题，敬请期待。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Jun 2016 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/06/05/GET%E5%92%8CPOST%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E4%B8%8A%E7%9A%84%E5%A4%9A%E6%95%B0%E7%AD%94%E6%A1%88%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/06/05/GET%E5%92%8CPOST%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E4%B8%8A%E7%9A%84%E5%A4%9A%E6%95%B0%E7%AD%94%E6%A1%88%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84/</guid>
        
        <category>Http</category>
        
        
        <category>技术博文</category>
        
      </item>
    
      <item>
        <title>Margin折叠，站在设计者的角度思考</title>
        <description>&lt;p&gt;大部分前端开发者在实现布局时，都会遇到Margin折叠的问题。CSS2.1标准文档中对Margin折叠的规则进行了标准的描述，但却没有解释这样设计的原因。使得我们想要摸清楚Margin折叠规则变得异常困难，通常需要死记硬背。 博主本人非常懒，这两天终于下定决心动动瓜脑子研究透彻Margin折叠。本篇文章我试图站在设计者的角度思考Margin折叠的设计思想，帮助自己和大家一起理解Margin折叠，抛开那些死记硬背。&lt;/p&gt;

&lt;h3 id=&quot;标准文档对margin的规定&quot;&gt;标准文档对Margin的规定&lt;/h3&gt;
&lt;h5 id=&quot;首先我们看看标准文档对margin的定义&quot;&gt;首先，我们看看标准文档对Margin的定义：&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;p&gt;原文：The width of the margin on non-floating block-level elements specifies the minimum distance to the edges of surrounding boxes. Two or more adjoining vertical margins (i.e., with no border, padding or content between them) are collapsed to use the maximum of the margin values. In most cases, after collapsing the vertical margins the result is visually more pleasing and closer to what the designer expects.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;翻译：外边距用来指定非浮动元素与其周围盒子边缘的最小距离。两个或两个以上的相邻的垂直外边距会被折叠并使用它们之间最大的那个外边距值。多数情况下，折叠垂直外边距可以在视觉上显得更美观，也更贴近设计师的预期。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注意： 如文档所说，margin是非浮动元素与周围盒子边缘的“最小”边距哦。它定义的只是外边距的最小值。&lt;/p&gt;

&lt;h5 id=&quot;为什么要有margin折叠&quot;&gt;为什么要有Margin折叠？&lt;/h5&gt;
&lt;p&gt;只有垂直Margin会发生折叠，而水平Margin则不会。这是为了排版的需要，因为在多数情况下，折叠垂直外边距可以在视觉上显得更美观，也更贴近设计师的预期。&lt;/p&gt;

&lt;h5 id=&quot;margin折叠规则&quot;&gt;Margin折叠规则&lt;/h5&gt;
&lt;p&gt;这里列出标准文档中的Margin折叠规则。快速浏览即可:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Two margins are adjoining if and only if:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;both belong to in-flow block-level boxes that participate in the same block formatting context&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;no line boxes, no clearance, no padding and no border separate them (Note that certain zero-height line boxes (see 9.4.2) are ignored for this purpose.)&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;both belong to vertically-adjacent box edges, i.e. form one of the following pairs: * top margin of a box and top margin of its first in-flow child * bottom margin of box and top margin of its next in-flow following sibling * bottom margin of a last in-flow child and bottom margin of its parent if the parent has ‘auto’ computed height * top and bottom margins of a box that does not establish a new block formatting context and that has zero computed ‘min-height’, zero or ‘auto’ computed ‘height’, and no in-flow children&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note the above rules imply that:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Margins between a floated box and any other box do not collapse (not even between a float and its in-flow children).&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Margins of elements that establish new block formatting contexts (such as floats and elements with ‘overflow’ other than ‘visible’) do not collapse with their in-flow children.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Margins of absolutely positioned boxes do not collapse (not even with their in-flow children).&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Margins of inline-block boxes do not collapse (not even with their in-flow children).&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;The bottom margin of an in-flow block-level element always collapses with the top margin of its next in-flow block-level sibling, unless that sibling has clearance.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;The top margin of an in-flow block element collapses with its first in-flow block-level child’s top margin if the element has no top border, no top padding, and the child has no clearance.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;The bottom margin of an in-flow block box with a ‘height’ of ‘auto’ and a ‘min-height’ of zero collapses with its last in-flow block-level child’s bottom margin if the box has no bottom padding and no bottom border and the child’s bottom margin does not collapse with a top margin that has clearance.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;A box’s own margins collapse if the ‘min-height’ property is zero, and it has neither top or bottom borders nor top or bottom padding, and it has a ‘height’ of either 0 or ‘auto’, and it does not contain a line box, and all of its in-flow children’s margins (if any) collapse.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;翻译：
两个Margin当且只有符合以下规则时，才会发生折叠:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;都属于文档流中的块级盒子，并且属于同一个BFC。&lt;/li&gt;
  &lt;li&gt;无line box, clearance, padding, border分离它们&lt;/li&gt;
  &lt;li&gt;都属于垂直相邻的盒子边界&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以上的规则暗示了：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;浮动盒子不会跟其它盒子发生margin折叠（即使是于它的子元素）。&lt;/li&gt;
  &lt;li&gt;创建BFC的盒子（如浮动根元素和overflow不为visible的元素）的Margin不会跟它的子元素发生margin折叠。&lt;/li&gt;
  &lt;li&gt;绝对定位的盒子不会发生margin折叠（即使与它的子元素）。&lt;/li&gt;
  &lt;li&gt;display为inline-block的元素不会发生margin折叠（即使与它的子元素）。&lt;/li&gt;
  &lt;li&gt;文档流中的会计元素的bottom margin总会和它的下一个文档流中的兄弟元素的top margin折叠，除非这个兄弟元素有clearance&lt;/li&gt;
  &lt;li&gt;如果文档流中一个元素没有top border, top padding，且它的子元素没有clearance，那么它的top margin会与它的第一个文档流中的块级子元素的top margin折叠。&lt;/li&gt;
  &lt;li&gt;如果文档流中的一个元素的高度为auto，min-height为0，且它没有bottom padding和bottom border，且它的子元素的bottom margin没有与拥有&lt;/li&gt;
  &lt;li&gt;当一个盒子的min-height为0，没有top或bottom borders，没有top或bottom padding，height为0或auto，不包含line box，且它的所有文档流中的子孙元素的margin都折叠了，那么它自己的top margin和bottom margin会折叠。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;margin设计思想-我的理解&quot;&gt;Margin设计思想-我的理解&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;只有文档流中的块级元素会发生Margin折叠。文档流外的元素，我们将它们看作是希望有特殊定位的元素，不应该应用文档流中常规文档的排版规则。因此， float不为none，或者position为absolute的元素，不会与兄弟元素发生margin折叠。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;display为inline-block的元素参与渲染上下文是Inline block center。其垂直位置不仅依赖于Margin，还依赖于自己所属的line box。因此也不应发生margin折叠。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;创建BFC的元素，不会与子元素发生margin折叠
    &lt;blockquote&gt;
      &lt;p&gt;BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如标准文档所说，BFC是一个独立的渲染区域，它内部的元素与这个区域外毫不相干，不会相互影响。因此，创建BFC元素ElementA，它的子元素的margin，不应该影响ElementA与其兄弟元素或父元素之间的间距。&lt;/p&gt;

&lt;p&gt;所以，符合以下条件触发BFC的元素，都不会与自己的子元素发生margin折叠：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;float属性不为none&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;position为absolute或fixed&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;display为inline-block, table-cell,&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;table-caption, flex, inline-flex&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;overflow不为visible&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当元素之间产生间隙时，可能不会发生margin折叠 元素之间可能由如下原因产生间隙：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;两个元素的margin之间存在border或padding阻挡时，两个元素的margin无法折叠。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;两个元素相邻，第二个元素由于设置了clear不为none，被浮动的元素挤下去，与第一个元素的margin可能折叠不完全，或者不折叠。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;防止margin折叠&quot;&gt;防止Margin折叠&lt;/h3&gt;
&lt;p&gt;如上所说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;只有文档流中的块级元素会发生Margin折叠,因此可通过将元素从文档流中去除，或者display设为inline-block的方式，防止其与兄弟节点发生margin折叠。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建BFC的元素，不会与子元素发生margin折叠 因此可通过触发元素的BFC，来防止它与自己的子元素发生Margin折叠&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当元素之间产生间隙时，可能不会发生margin折叠 因此可通过padding,border来制造间隙，以防止margin折叠&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这篇文章是我试图站在设计者的角度，对Margin折叠设计思想的理解。避免死记硬背这些规则。大家如果有不同的理解，欢迎讨论。&lt;/p&gt;
</description>
        <pubDate>Mon, 04 May 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2015/05/04/Margin%E6%8A%98%E5%8F%A0-%E7%AB%99%E5%9C%A8%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2015/05/04/Margin%E6%8A%98%E5%8F%A0-%E7%AB%99%E5%9C%A8%E8%AE%BE%E8%AE%A1%E8%80%85%E7%9A%84%E8%A7%92%E5%BA%A6%E6%80%9D%E8%80%83/</guid>
        
        <category>Css Margin</category>
        
        
        <category>技术博文</category>
        
      </item>
    
      <item>
        <title>关于操作系统的一些介绍</title>
        <description>&lt;h4 id=&quot;主流操作系统&quot;&gt;主流操作系统&lt;/h4&gt;
&lt;p&gt;最近在倒腾 Linux 系统，自己其实是一个 Linux 的菜鸟，很多 Linux 的一些命令都没有深入的研究、实用，但是因为一些原因必须去折腾 Linux 系统。说起操作系统，现在主流的操作系统，无外乎就是 Windows、 Linux、Unix。&lt;/p&gt;

&lt;p&gt;对于 Linux，耳熟能详的 Ubuntu、CentOS、RedHat、Fedora 等等。那他们到底和 Linux 是什么关系呢？对于刚介绍 Linux 系统的人来说，可能有点迷茫的。那就拿 Windows 来做说明对比好了。天国的子民很多人都是用 Windows 系统，但是很多都是盗版的。很多人可能就说买电脑时自带的是正版的啊，其中具体是不是正版的，仔细研究一些资料就知道是不是正版的 or 很有可能就是一个正版的镜像，说白了就是一个复制品。很多 Windows 用户重装系统一般都是在网上下载一个镜像文件，然后刻录到 U盘或者是光盘中，然后进行安装。然后进入系统之后，查看系统的详细信息，可能是雨林木风或者是深度的。那么前面提到 Linux 中的 Ubuntu、CentOS等等就等同于 Windows 系统中的雨林木风、深度等等。区别就是 Ubuntu、CentOS 不是盗版的，而雨林木风、深度基本上都是盗版，原因就是 Linux 系统是开源的，不存在盗版只说。那么有人就会问 Windows 有 Windows XP、Windows Vista、Windows 7、Windows 8、Windows 10等，这些其实是 Windows 系统的版本。对应的雨林木风、深度的也有 XP、Win7等版本的。在 Linux 中也是一样的，Ubuntu 有 Ubuntu 10.04、Ubuntu 10.10等，目前应该到了 Ubuntu 12.04 了。CentOS 也有5、6、7等等。&lt;/p&gt;

&lt;p&gt;想必大家应该搞清楚 Linux 系统的一些概念了，好了那么来说说 Unix。Unix 系统是一个很古老的操作系统，一般人很少接触到。但是说到 Mac OS，估计很多人都在使用。Mac OS系统是在 Unix 系统上开发出来的，简单就是说 Apple 给 Unix 系统做了图形界面，于是就有了自己的 Mac OS 系统了，可是实际上可能不是这么简单的。&lt;/p&gt;

&lt;h4 id=&quot;unix-和-linux&quot;&gt;Unix 和 Linux&lt;/h4&gt;
&lt;p&gt;Linux和UNIX的最大的区别是，前者是开发源代码的自由软件，而后者是对源代码实行知识产权保护的传统商业软件。这应该是他们最大的不同，这种不同体现在用户对前者有很高的自主权，而对后者却只能去被动的适应；这种不同还表现在前者的开发是处在一个完全开放的环境之中,而后者的开发完全是处在一个黑箱之中,只有相关的开发人员才能够接触的产品的原型。&lt;/p&gt;

&lt;p&gt;Linux 的源头要追溯到最古老的UNIX。1969年，Bell实验室的Ken Thompson开始利用一台闲置的 PDP-7计算机开发了一种多用户，多任务操作系统。很快，Dennis Richie加入了这个项目，在他们共同努力下诞生了最早的UNIX。Richie受一个更早的项目——MULTICS的启发，将此操作系统命名为 Unix。早期UNIX是用汇编语言编写的，但其第三个版本用一种崭新的编程语言C重新设计了。C是Richie设计出来并用于编写操作系统的程序语言。通过这次重新编写，Unix得以移植到更为强大的 DEC PDP-11/45与11/70计算机上运行。后来发生的一切，正如他们所说，已经成为历史。Unix从实验室走出来并成为了操作系统的主流，现在几乎每个主要的计算机厂商都有其自有版本的Unix.&lt;/p&gt;

&lt;p&gt;Linux起源于一个学生的简单需求。Linus Torvalds,Linux的作者与主要维护者，在其上大学时所买得起的唯一软件是Minix. Minix是一个类似Unix，被广泛用来辅助教学的简单操作系统。Linus 对Minix不是很满意，于是决定自己编写软件。他以学生时代熟悉的Unix作为原型， 在一台Intel 386 PC上开始了他的工作。他的进展很快，受工作成绩的鼓舞，他将这项成果通过互连网与其他同学共享，主要用于学术领域。有人看到了这个软件并开始分发。每当出现新问题时，有人会立刻找到解决办法并加入其中，很快的， Linux成为了一个操作系统。值得注意的是Linux并没有包括Unix源码。它是按照公开的POSIX标准重新编写的。Linux大量使用了由麻省剑桥免费软件基金的GNU软件，同时Linux自身也是用它们构造而成。&lt;/p&gt;

&lt;h5 id=&quot;另外两大区别&quot;&gt;另外两大区别：&lt;/h5&gt;

&lt;p&gt;　　1） UNIX系统大多是与硬件配套的，而Linux则可运行在多种硬件平台上.&lt;/p&gt;

&lt;p&gt;　　2） UNIX是商业软件，而Linux是自由软件，免费、公开源代码的.&lt;/p&gt;

&lt;p&gt;　　UNIX(5万美圆)而Linux免费&lt;/p&gt;

&lt;p&gt;　　[历史]&lt;/p&gt;

&lt;p&gt;　　Unix的历史久于linux. Linux的思想源于Unix&lt;/p&gt;

&lt;p&gt;　　[产品]&lt;/p&gt;

&lt;p&gt;　　unix和linux都是操作系统的名称．但unix这四个字母除了是操作系统名称外，还作为商标归SCO所有．&lt;/p&gt;

&lt;p&gt;　　Linux商业化的有RedHat Linux 、SuSe Linux、slakeware Linux、国内的红旗等，还有Turbo Linux.&lt;/p&gt;

&lt;p&gt;　　Unix主要有Sun 的Solaris、IBM的AIX,　HP的HP-UX，以及x86平台的的SCO Unix/Unixware&lt;/p&gt;

&lt;p&gt;　　[其他区别]&lt;/p&gt;

&lt;p&gt;　　linux的核心是免费的，自由使用的，核心源代码是开放的．&lt;/p&gt;

&lt;p&gt;　　而unix的核心并不公开&lt;/p&gt;

&lt;p&gt;　　在对硬件的要求上，linux比unix要低，没有unix那么苛刻．在安装上linux比unix容易掌握．&lt;/p&gt;

&lt;p&gt;　　在使用上，linux相对没有unix那么复杂．&lt;/p&gt;

&lt;p&gt;Unix多数是硬件厂商针对自己的硬件平台的操作系统，主要与CPU等有关，如Sun 的Solaris作为商用，定位在其使用SPARC/SPARCII的CPU的工作站及服务器上，当然Solaris也有x86的版本，而Linux也有其于RISC的版本。&lt;/p&gt;

&lt;p&gt;但确切的讲，拿RISC上的Unix与x86上的Linux进行比较不太合适。至于价格，个人使用的Linux基本上算是免费的，不同的Linux发行厂商针对企业级应用在基本的系统上有些优化，如RedHat的Enterprise产品，这些产品包括支持服务是比较贵的。像IBM/HP/SUN的Unix，因为主要是针对其硬件平台，所以操作系统通常在设备价格中。(没有人单独去买一个Unix操作系统的)&lt;/p&gt;

&lt;p&gt;在性能上，linux没有unix那么全面，但基本上对个人用户和小型应用来说是绰绰有余．&lt;/p&gt;

&lt;p&gt;通常情况下，如果你有机会使用到Unix环境，比如银行、电信部门，那一般都是固定机型的Unix。比如电信里SUN的居多，民航里HP的居多，银行里IBM的居多。学习中，不同的Unix命令集有些不同，要注意。&lt;/p&gt;

&lt;p&gt;至于学习，我看还是linux比较好学一点，而且现在喜欢和鼓捣linux的人也越来越多，各种有关linux的资料也很多．如果是自己想学习，那Linux或是BSD系统是不错的选择。一台x86的机器就可以。应用上，除非是大型网站，一般企业或个人，使用Linux即可.&lt;/p&gt;

&lt;p&gt;UNIX是一个功能强大、性能全面的多用户、多任务操作系统，可以应用从巨型计算机到普通PC机等多种不同的平台上，是应用面最广、影响力最大的操作系统。&lt;/p&gt;

&lt;p&gt;Linux是一种外观和性能与UNIX相同或更好的操作系统，但，Linux不源于任何版本的UNIX的源代码，并不是UNIX，而是一个类似于UNIX的产品。Linux产品成功的模仿了UNIX系统和功能，具体讲Linux是一套兼容于System V以及BSD UNIX的操作系统，对于System V来说，目前把软件程序源代码拿到Linux底下重新编译之后就可以运行，而对于BSD UNIX来说它的可执行文件可以直接在Linux环境下运行。&lt;/p&gt;

&lt;p&gt;一般来说，Linux是一套遵从POSIX（可移植操作系统环境）规范的一个操作系统，它能够在普通PC计算机上实现全部的UNIX特性，具有多任务、多用户的能力。Linux受到广大计算机爱好者的喜爱的另一个主要原因是，它具有UNIX的全部功能，任何使用UNIX操作系统或想要学习UNIX操作系统的人都可以从Linux中获益。&lt;/p&gt;

&lt;p&gt;在网络管理能力和安全方面，使用过Linux的人都承认Linux与UNIX很相似。UNIX系统一直被用做高端应用或服务器系统，因此拥有一套完善的网络管理机制和规则，Linux沿用了这些出色的规则，使网络的可配置能力很强，为系统管理提供了极大的灵活性。&lt;/p&gt;
&lt;h4 id=&quot;windows-系统&quot;&gt;Windows 系统&lt;/h4&gt;
&lt;p&gt;Windows 系统之前应该是 Microsoft 的 Dos 系统，就是黑框框的字符界面，现在 Linux 的 Server 版就是这样的。后来因为乔布斯准备做图形界面而盖茨抄袭了这一想法，产生了 Windows 系统，至于究竟是谁抄谁，我所了解到的是乔帮主也是抄袭别人的想法的吧。不过至少这些确实推动了行业的进步。&lt;/p&gt;

&lt;h4 id=&quot;三大操作系统使用的对象&quot;&gt;三大操作系统使用的对象&lt;/h4&gt;
&lt;p&gt;很多 Windows 用户觉得 Linux 系统使用起来很难受，确实对于一些没有计算机专业至少的人来说，使用 Linux 简直就是噩梦。对于做维护的人来说，Linux 对他们来说简直是利器。很多一些问题。啪啪敲入一些字符就 OK 了。简直就是高大上啊！而 Mac OS 就是装逼，用 Mac OS就是为了装逼的&lt;/p&gt;

&lt;p&gt;但是客观来说，Windows 有自己的图形界面，确实很方便，但是 Windows 的内存管理真的是不敢恭维，可能这是当年 Microsoft 和 Intel 的战略导致的吧。Intel 能生产多好的硬件，Microsoft 的 Windows 系统就吃多少硬件，用户不得不更换硬件，两大巨头确实赚了不少钱，但是现在看来当年他们完全是自己给自己挖坑。现在的 Linux 和 Mac OS 也都有了图形界面，而且他们可以运行在更低配置的硬件上。&lt;/p&gt;

&lt;p&gt;如果你是一个开发人员的话，估计多多少少碰到 Windows 系统的一些问题吧。搭建开发环境的时候，简直是坑爹啊，装Python、Go、Ruby等等基于他们写的一些小工具简直是不能忍受的。&lt;/p&gt;

&lt;p&gt;Linux 本身发行的时候就集成了这些东西，所以搭建相应的开发环境可能就是一行命令。而他的缺陷就是在于一些软件对 Linux 的支持不是很好，顶顶大名的 QQ 居然 Linux 版本好多年没有更新了。哈哈，只能说用 Linux 的人都不屑于用 QQ 来交流吧。所以说 Linux 有很好的开发环境但是没有很好的图形界面。&lt;/p&gt;

&lt;p&gt;Mac OS 就不一样了，现在很多的软件基本上都有 Windows 版和 Mac 版，所以软件支持很好。而且 Mac 的软件图形界面都是很漂亮的。而且 Mac OS 发行的时候也是集成了很多的开发语言，所以对于开发来说 Mac OS应该是首选。&lt;/p&gt;

&lt;h4 id=&quot;个人的感悟&quot;&gt;个人的感悟&lt;/h4&gt;
&lt;p&gt;刚接触计算机的时候都是用 Windows 的，后来接触了一些 Linux，但是确实没有很长时间的在上面做过一些开发的。后来就转到 Mac OS 开发。其实也有些人买了 Mac 电脑，然后装了一个 Windows 的操作系统，我真的只能说是暴殄天物，因为 Mac OS 真的是很容易上手的。只能就像你之前用 Android，然后买了一个 iPhone 手机，其实学习成本是很低的。但是你想用的很好，还是需要很多的学习。之前有一两个月的时候是在 Ubuntu 下开发的，感觉就是 Linux 系统很强大，但是需要很深的功力才能很好的驾驭它。
还有一点感触就是使用 Windows 的时候，一些一个程序卡死了，基本上什么操作都不能做了，其他软件也不能使用了，只能杀死进程了。而对于 Mac OS 来说，当一个程序卡死了，其他软件还是正常的使用。&lt;/p&gt;

&lt;h4 id=&quot;如何选择&quot;&gt;如何选择&lt;/h4&gt;
&lt;p&gt;至于如何选择，这个得看个人吧。很多虽然是计算机专业的，但是真的是喜欢一层不变的，解决问题的能力很差，不去折腾，这样的话，还是选择 Windows 吧。但是你的技能很可能一直不会有很大的提升的。有一些 Linux 命令的基础的话，在经济实力允许的情况下还是选择 Mac OS，因为 Linux 很容易折腾坏了。&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2015/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2015/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BB%8B%E7%BB%8D/</guid>
        
        <category>Operation System</category>
        
        
        <category>技术博文</category>
        
      </item>
    
      <item>
        <title>搭建自己的 Ubuntu 环境（一）</title>
        <description>&lt;h4 id=&quot;写在前面&quot;&gt;写在前面&lt;/h4&gt;
&lt;p&gt;安装 Ubuntu 后，为了方便操作，选择使用 SSH 来远程操作 Ubuntu，这样不用两台机子来回操作，在一台机器上就可以操作另外一个机器，这样就方便了很多。
ssh是一种安全协议，主要用于给远程登录会话数据进行加密，保证数据传输的安全，现在介绍一下如何在Ubuntu 14.04上安装和配置ssh&lt;/p&gt;

&lt;h4 id=&quot;工具原料&quot;&gt;工具／原料&lt;/h4&gt;
&lt;p&gt;1.Ubuntu 14.04&lt;/p&gt;

&lt;h4 id=&quot;安装部署-ssh-服务器&quot;&gt;安装部署 SSH 服务器&lt;/h4&gt;
&lt;p&gt;下面的操作都必须在你的 Ubuntu 机器上，因为没有 SSH 服务器端，你根本没有办法连接到 Ubuntu 机器上。&lt;/p&gt;

&lt;h3 id=&quot;更新源列表&quot;&gt;更新源列表&lt;/h3&gt;
&lt;p&gt;打开“终端窗口”或者使用快捷键“ctrl＋alt＋t”打开，在终端中输入“sudo apt-get update”–&amp;gt;回车–&amp;gt;,输入当前登陆用户的密码，回车即可。
&lt;img src=&quot;/public/img/ubuntu-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;安装ssh&quot;&gt;安装SSH&lt;/h5&gt;
&lt;p&gt;在终端中输入“sudo apt-get install openssh-server”–&amp;gt;回车–&amp;gt;按要求输入“Y”或者“n”–&amp;gt;回车，完成安装&lt;/p&gt;

&lt;h5 id=&quot;查看ssh服务是否启动&quot;&gt;查看SSH服务是否启动&lt;/h5&gt;
&lt;p&gt;在终端输入“sudo ps -e | grep ssh”–&amp;gt;回车–&amp;gt;有 sshd，说明 ssh 服务已经启动，如果没有启动，输入“sudo service ssh start”–&amp;gt;回车–&amp;gt;ssh服务就会启动。
&lt;img src=&quot;/public/img/ubuntu-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ssh-登陆&quot;&gt;ssh 登陆&lt;/h4&gt;
&lt;p&gt;以上的步骤基本上就完成安装了，一些具体的可能需要配置 ssh 服务器，在终端中输入“sudo vim /etc/ssh/sshd_config”–&amp;gt;回车，使用 vim 修改其中的响应配置。&lt;/p&gt;

&lt;p&gt;接下来就是其他机器通过 ssh 来登陆到改 Ubuntu 了。我们称刚才安装 ssh  服务器端的 Ubuntu 系统的机器为 A，那么我们其他的机器 B 想通过 ssh 来远程到机器 A的话，就必须在机器 B 上安装 ssh 的客户端， Ubuntu 14.04 默认安装了 ssh 客户端的，Mac OS也是默认安装了 ssh 客户端。&lt;/p&gt;

&lt;p&gt;下面以Mac OS（机器 B）为例通过 ssh 远程到 Ubuntu（机器 A）&lt;/p&gt;

&lt;p&gt;Mac OS 上打开终端或者是 iTerm， 输入“ssh chenglong@192.168.1.102”–&amp;gt; 回车，
其中 ssh 连接的格式是 ssh user@ip，以上的命令 “chenglong” 是 Ubuntu（机器 A）上的一个用户， “192.168.1.102” 是 Ubuntu （机器 A）的 IP 地址。
回车后，要求我们输入密码，这个密码是机器 A 上user（即“chenglong”）对应的登陆密码。
之后便会链接成功。
&lt;img src=&quot;/public/img/ubuntu-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;连接错误&quot;&gt;连接错误&lt;/h4&gt;
&lt;p&gt;之上登陆后，因为我们是通过“用户名和 IP 地址”来建立的 ssh 连接，所以在Mac OS（机器 B）上写入了一个 RSA 值，所以如果 Ubuntu （机器 A）重装系统，在根据“用户名和 IP 地址”来 ssh 登录的时候，如果‘机器 A’的 IP 地址不变的话，会出现错误。原因是重装系统后‘机器 A’ 会重新生成一个 RSA，那么‘机器 B’上记录的还是 IP 和原有的 RSA 的对应关系。所以此时最简单的解决方法就是在‘机器 B’上删除原有的那条信息就 OK 了。
Mac OS上盖条信息存在 用户住目录下&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;~/.ssh/known_hosts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/public/img/ubuntu-4.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/public/img/ubuntu-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过 ip 查找到该条记录删除之，即可。然后 ssh 重新连接。&lt;/p&gt;

&lt;p&gt;如果是多个人连接‘机器 A’，还可以通过配置 RSA 来使用 ssh 远程连接，这样的话就不需要每次使用 ssh 远程的时候输入‘机器 A’上的用户密码了。这需要将‘机器 B’、‘机器 C’、‘机器 D’…上的 RSA 都保存在‘机器 A’上，具体配置请 Google 之。&lt;/p&gt;
</description>
        <pubDate>Wed, 22 Apr 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2015/04/22/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-Ubuntu-%E7%8E%AF%E5%A2%83/</link>
        <guid isPermaLink="true">http://localhost:4000/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2015/04/22/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84-Ubuntu-%E7%8E%AF%E5%A2%83/</guid>
        
        <category>Ubuntu</category>
        
        
        <category>技术博文</category>
        
      </item>
    
  </channel>
</rss>
