<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      异次元杀阵之最大子段和的破解之法 &middot; fri3nds
    
  </title>

  <!-- CSS -->
  <!-- <link rel="stylesheet" href="/public/css/syntax.css"> -->
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="/public/css/pygments.css">
  <link rel="stylesheet" href="/public/css/font-awesome.min.css">
  <!-- <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400"> -->

  <!-- Icons -->
  <!-- <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/img/apple-touch-icon-144-precomposed.png"> -->
  <link rel="shortcut icon" href="/public/img/chenglong.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <!-- livereload test -->
  <!--<script>document.write('<script src="http://' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1"></' + 'script>')</script>-->

  <!-- audioplayer -->
  <script src="/public/js/jquery-1.11.1.js"></script>
  <script src="/public/js/audioplayer/amazingaudioplayer.js"></script>
  <link rel="stylesheet" type="text/css" href="/public/css/audioplayer/initaudioplayer-1.css">
  <script src="/public/js/audioplayer/initaudioplayer-1.js"></script>
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?32fe7477dc34484123ca3fe5001749c6";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
</head>


  <body class="">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <div class="sidebar-logo">
      <a href="/"><img src="/public/img/chenglong.jpg"></a>
    </div>
    <p>Here is my personal weblog about technology and life.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/"><i class="fa fa-home fa-fw"></i>&nbsp 主页·&nbspHome</a>
    <a class="sidebar-nav-item" href="/archive/"><i class="fa fa-file-text-o fa-fw"></i>&nbsp 归档·&nbspArchive</a>
    <a class="sidebar-nav-item" href="/category/"><i class="fa fa-book fa-fw"></i>&nbsp 分类·&nbspCategory</a>
    <a class="sidebar-nav-item" href="/tag/"><i class="fa fa-tags fa-fw"></i>&nbsp 标签·&nbspTag</a>
    <a class="sidebar-nav-item" href="/about/"><i class="fa fa-hand-o-right fa-fw"></i>&nbsp 关于·&nbspAbout</a>
    <!-- <span class="sidebar-nav-item"><i class="fa fa-info-circle">&nbsp&nbsp  </i>Currently v1.0.0</span> -->
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2018. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <div class="masthead-title">
            <a href="/" title="Home">fri3nds</a>
            <small>A craftsman typing carefully</small>
          </div>
        </div>
      </div>

      <div class="container content">
        <h2 class="post-name">Blog</h2>
<div class="post">
  <div class="post-heading inside">
    <img src="/public/img/chenglong.jpg">
    <h1 class="post-title">
      <a class="post-title-blog" href="">
        异次元杀阵之最大子段和的破解之法
      </a>
    </h1>
      <p class="post-info">
        
          fri3nds 原创
        
      </p>
      <span class="post-info"><i class="fa fa-calendar"></i>&nbsp2016/09/25  </span>
      <span class="post-info"><i class="fa fa-book"></i>&nbsp<a href="/category/index.html#技术博文">技术博文</a></span>
      
        <span class="post-info">&nbsp<a href="/tag/index.html#算法">算法</a></span>
      
  </div>
  <div class="post-content">
    <h3 id="1-前言">1. 前言</h3>
<p>首先解释一下这个标题。</p>

<p>最近看了一个关于密室的系列电影，共有三部，个人只觉得第一部比价好看(ps:第三部还没有看)，它有两个名字，一个叫《心慌方》，比较文艺；两一个也叫《心慌方》，当然不可能了，其实是《异次元杀阵》，这个听上去比较科技感强一点。</p>

<p>最大子段和，也叫<code class="highlighter-rouge">最大连续子数列和</code>,AC圈都是这么叫的吧。我个人喜欢前面一个。最近也是看到有博主也写关于这个问题的算法，所以自己也想提笔试着写写(非喜勿喷)。关于<code class="highlighter-rouge">最大连续子数列和</code>的解释可以看 <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98">维基百科</a>。</p>

<p>为什么把两者扯到一起，因为我下面要讲的是解决这个问题的过程，如何演化！</p>

<h3 id="2-坐标">2. 坐标</h3>
<p>最容易想到的方法就是枚举，所以的情况都枚举出来，比较一下大小就可以了。</p>

<p>以数组</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> A = [-2, 11, -4, 13, -5, -2]
</code></pre></div></div>
<p>为例。</p>

<p>关于如何枚举，我个人容易想到的是2种；</p>
<h5 id="1-按子序列的长度枚举">(1) 按子序列的长度枚举</h5>
<h5 id="2-按子序列的起点终点枚举">(2) 按子序列的起点、终点枚举</h5>
<p>二者其实是一样的，知道起始点就知道长度了，只是第二种记录起始点听上去顺理成章一点。本质上时间复杂度都是<code class="highlighter-rouge">O(n^3)</code></p>

<p>解法1</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var A = [-2, 11, -4, 13, -5, -2];
var ans = A[0];
var s;

for(var n = 1; n &lt;= A.length; n++) {
  for(var i = 0; i &lt; A.length; i++) {
    s = 0;
    for(var j = 0; j &lt; n; j++) {
      s += A[i+j];
    }
    if (s &gt; ans) {
      ans = s;
    }
  }
}

console.log(ans, '=========');
</code></pre></div></div>
<p>解法2</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var A = [-2, 11, -4, 13, -5, -2];
var ans = A[0];
var s;

for(var i = 0; i &lt; A.length; i++) {
  for(var j = i; j &lt; A.length; j++) {
    s = 0;
    for(var k = i; k &lt;= j ; k++) {
      s += A[k];
    }
    if (s &gt; ans) {
      ans = s;
    }
  }
}

console.log(ans, '=========');
</code></pre></div></div>

<p>两中方法其实都是通过记录起始点的手段来来解决问题，也就是记录<code class="highlighter-rouge">坐标</code>，有点像《心慌方》中理科女，通过坐标来辨识安全的房间.
(在更新 ans 的时候，可以记录相应的起始点，就得到我们想要的<code class="highlighter-rouge">坐标</code>了)</p>

<p>两种枚举的方法都其实是引入了两个变量，在解决很多数学问题上，一些问题通过<code class="highlighter-rouge">消元</code>和<code class="highlighter-rouge">降次</code>基本上可以解决了。
这种思路也适用于算法设计。
此外，计算机很多的问题都是<code class="highlighter-rouge">量</code>导致的，如果<code class="highlighter-rouge">量</code>很小的话，问题很容易解决。</p>

<p>仔细观察 <code class="highlighter-rouge">解法2</code> 可以发现，我们很多次循环都是在求解 A[i…j] 的累加和，如何避免这种重复的劳动了，
在计算机上面，可以使用另外一种优化手段，<code class="highlighter-rouge">空间换时间</code> ，当然也存在 <code class="highlighter-rouge">时间换空间</code> 的</p>

<p>由此可以引申出 3 种优化思路：</p>
<h5 id="1-空间换时间">(1) <code class="highlighter-rouge">空间换时间</code></h5>
<h5 id="2-通过降量-来优化这个问题的解计算机">(2) 通过降”量” 来优化这个问题的解(计算机)</h5>
<h5 id="3-通过-消元-或者-降次-来优化这个问题的解数学">(3) 通过 “消元” 或者 “降次” 来优化这个问题的解(数学)</h5>

<h3 id="3-备忘录">3. 备忘录</h3>
<p><code class="highlighter-rouge">解法2</code> 中多次求解 A[i…j] 的累加和，如果能够花费一些空间把它记录下来，不就是省掉一层循环了，降低了时间复杂度；
实际上很多问题都可以通过备忘录，来省去重复的工作。</p>

<p>如果用 sum[i] 表示 A 中 A[0] 到 A[i] 的累加和，那么 A[i..j] = sum[j] - sum[i-1];
我们在外层计算出数组 sum，记录下来，在需要用到 A[i…j] 的时候，通过简单的减法运算就可以实现了，减少了一层循环，时间复杂度就降低到 <code class="highlighter-rouge">O(n^2)</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
var A = [-2, 11, -4, 13, -5, -2];
var sum = [];
sum[0] = A[0];
var ans = A[0];
var s;

for(var i = 1; i &lt; A.length; i++) {
  sum[i] = sum[i-1] + A[i];
}
for(i = 1; i &lt; A.length; i++) {
  for(var j = i; j &lt; A.length; j++) {
    s = sum[j] - sum[i-1];
    if (s &gt; ans) {
      ans = s;
    }
  }
}

console.log(ans, '=========');

</code></pre></div></div>

<h3 id="4-降-量">4. 降 “量”</h3>
<p>尝试了第一种优化方式，确实得到了一些优化，那继续尝试第二种咯。</p>

<p>一般在很多问题的处理上，都是通过降 “量” 来优化，比如预先排除一些没有用的数据，来降低数据的量级。而我们这个问题是没有办法
直接通过预先处理、筛选一些数据解决的。</p>

<p>但是最大子段和问题，我们可以换一种方式来理解降 “量”。</p>

<p>如果整个序列只有 1 个或者 2 个元素，问题是不是简单很多。我们解决只有 1 个元素的序列的最大子段和问题，那么就可以解决只有 2 个
元素的最大子段和，进而 4 个、8 个，……</p>

<p>是不是突然感觉有点熟悉，<code class="highlighter-rouge">分治</code> 感觉已经呼之欲出了。对，就是 <code class="highlighter-rouge">分而治之</code></p>

<p>求解整个序列的最大子段和，我们可以分解成两部分:</p>

<blockquote>
  <p>求左半部分的最大子段和，</p>
</blockquote>

<blockquote>
  <p>求右半部分的最大子段和，</p>
</blockquote>

<blockquote>
  <p>根据左、右两个半部分的最大子段和，求解整个序列的最大子段</p>
</blockquote>

<p>求解左、右半部分的最大字段和最后都可以分解成 “只有 1 个元素的序列的最大子段和问题”，这大概就是<code class="highlighter-rouge">一个小目标</code>.</p>

<p>那么 “只有 2 个元素的序列的最大子段和问题” 可以通过上面的<code class="highlighter-rouge">小目标</code>来实现。如果左半部分的最大子段和是 0，那整个序列的最大子段和就在右半部分；如果右半部分的最大子段和是 0，那整个序列的最大子段和就在左半部分；(如果左右都为 0，上述那个如果都满足，依旧是 0)
剩余的情况就是整个序列的最大子段和由 <code class="highlighter-rouge">左半部分的最大子段和</code> 和 <code class="highlighter-rouge">右半部分的最大字段和</code> 共同组成。</p>

<p>这其实就是<code class="highlighter-rouge">分治</code>问题的核心，如何由小的问题汇总大的问题，怎么由<code class="highlighter-rouge">先赚它一个亿</code>到成为<code class="highlighter-rouge">首富</code>的问题。</p>

<p>具体问题具体分析，最大子段和，也叫最大连续子数列和。关键词是连续。
于是这个问题就是最大连续子序列和要么出现在数组左半部分，要么出现在数组右半部分，要么横跨左右两半部分。横跨左右两半部分就受到连续这个关键词的限制。</p>

<p>具体解法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var A = [-2, 11, -4, 13, -5, -2];
function MaxSubSequence(left, right) {
  if (left &gt; right) {
    return 0;
  }
  // 只有 1 个元素的序列
  if (left === right) {
    return A[left];
  }

  // 划分为 “左半部分的最大子段和” 和 "右半部分的最大子段和"
  var mid = (left + right) / 2;
  mid &gt;&gt;&gt;= 0;
  var leftMaxSubSequence = MaxSubSequence(left, mid);
  var rightMaxSubSequence = MaxSubSequence(mid + 1, right);

  // 求横跨左右的最大连续子序列左半部分
  var lmax = A[mid], lsum = 0;
  for(var i = mid; i &gt;= left; i--) {
    lsum += A[i];
    if (lsum &gt; lmax) {
      lmax = lsum;
    }
  }

  // 求横跨左右的最大连续子序列右半部分
  var rmax = A[mid + 1], rsum = 0;
  for(var j = mid + 1; j &lt;= right; j++) {
    rsum += A[j];
    if (rsum &gt; rmax) {
      rmax = rsum;
    }
  }
  return Math.max(lmax + rmax, leftMaxSubSequence, rightMaxSubSequence); //返回三者最大值
}

var ans = MaxSubSequence(0, A.length - 1);
console.log(ans, '===============');

</code></pre></div></div>

<p>整个解法的时间复杂度是 <code class="highlighter-rouge">O(n*lgn)</code></p>

<p>其实我们，可以看到解决这个问题的过程中，我们实际上还是依赖于两个变量，left 和 right，并没有<code class="highlighter-rouge">消元</code></p>

<p>接下来，我们试试<code class="highlighter-rouge">消元</code>吧。</p>

<h3 id="5-消元">5. 消元</h3>
<p>前面的两种优化手段依旧和<code class="highlighter-rouge">坐标</code>有关系，还是二元，我们尝试一下消元。</p>

<p>一直停留在最大连续子数列和起点和终点上，一直不能愉快地消元，实际这个问题，不管原序列有多少个元素，都有起点和终点，但是
如果只有 1 个元素的话，是不是起点和终点重合，如果原序列很长，就是终点很远，但是起点还是起点，不管原序列多长，变化一直是终点，
所以可不可以不关心起点，只 care 我们的终点，把起点这个<code class="highlighter-rouge">元</code>消除掉。</p>

<p>ok，于是我们假设 max[j] 是 序列 A[0…j] 的最大字段和。能不能通过类似数学归纳法来求得一个递推公式呢？！</p>

<p>我们需要解决的就是如何从 max[j] 求出 max[j+1] 的值。</p>

<p>最大连续子数列和，其中关键就是连续。 
从 max[j] 到 max[j+1] ，考虑连续与否就可以了。</p>

<blockquote>
  <p>a. max[j] 的终点是 A[j]
b. max[j] 的终点不是 A[j]</p>
</blockquote>

<h4 id="a-maxj-的终点是-aj">a. max[j] 的终点是 A[j]</h4>
<p>那么 max[j+1] = Max(max[j-1], max[j-1] + A[j])</p>
<h4 id="b-maxj-的终点不是-aj">b. max[j] 的终点不是 A[j]</h4>
<p>假设 max[j] 的终点是 A[m]
那么 max[j+1] = Max(max[j-1], max[j-1] + (A[m+1] + A[m+2] + … + A[j]) )</p>

<p>综上，在递推的过程中我们记录终点 m 就可以了.</p>

<p>所以在遍历的 j 的时候，记录更新 m 就可以了。而记录终点 m 也是为了求 (A[m+1] + A[m+2] + … + A[j])，
tmp 记录 A[m+1] 到 A[j-1] 的累积和</p>
<blockquote>
  <p>如果 tmp + A[j] + max[j-1] &gt; max[j-1] ，max[j] = max[j-1] + tmp + A[j], tmp 也相应地更新为 0；
如果 tmp + A[j] + max[j-1] &lt;= max[j-1] ，max[j] = max[j-1], tmp 也相应地更新为 tmp + A[j]；</p>
</blockquote>

<p>具体解法</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var A = [-2, 11, -4, 13, -5, -2];
var ans = 0;
var tmp = 0; // 记录 A[m+1] + A[m+2] + ... + A[j-1]

for(var j = 0; j &lt; A.length; j++) {
  if (tmp + A[j] &gt; 0) {
    ans += A[j] + tmp;
    tmp = 0;
  } else {
    if (j != 0 ) { // 处理序列第一个元素 A[0] &lt; 0
      tmp += A[j];
    }
  }
}

console.log(ans, '=========');

</code></pre></div></div>
<p>该解法的时间复杂度为 <code class="highlighter-rouge">O(n)</code></p>

<h3 id="6-降维">6. 降维</h3>

<p>降维，通过低维打击高维，才是王道。上面的 <code class="highlighter-rouge">O(n)</code> 算法中，<code class="highlighter-rouge">max[]</code> 只需要 <code class="highlighter-rouge">max[j]</code> 和 <code class="highlighter-rouge">max[j-1]</code>，所以可以用一个变量 <code class="highlighter-rouge">ans</code> 即可解决问题。 在很多动态规划的算法中，可以通过<code class="highlighter-rouge">降维</code>来实现空间复杂度的优化， 例如 <code class="highlighter-rouge">dp[i][j] = Max(dp[i-1][j], dp[i][j-1])</code> 之类的， 数组 <code class="highlighter-rouge">dp[][]</code> 只用到了 <code class="highlighter-rouge">dp[i-1]</code> 和 <code class="highlighter-rouge">dp[i]</code>，我们完全可以通过 <code class="highlighter-rouge">dpmin[]</code> 来取代 <code class="highlighter-rouge">dp[][]</code>，优化空间复杂度。</p>

<p>还有一些动态规划的问题中，例如 <code class="highlighter-rouge">dp[i][j] = Max(∑dp[i-1][n](0&lt;=n&lt;j)*A[i][j], A[i][j])</code> 之类的， <code class="highlighter-rouge">dp[i]</code> 的状态与整个 <code class="highlighter-rouge">dp[i-1]</code> 数组都有关系的时候， 我们也可以用过 <code class="highlighter-rouge">b[j] = Max(∑a[n](0&lt;=n&lt;j)*A[i][j], A[i][j]); a[] = b[]</code>，<code class="highlighter-rouge">a[]</code> 和 <code class="highlighter-rouge">b[]</code> 做一个交换来优化空间复杂度，当然这样每次交换也牺牲了一部分的效率。</p>

<h3 id="扩展">扩展</h3>
<p>文章提到的一些解法和优化方法，实际上被大神设计出来，掌握这些最本质的东西，在解决实际问题的时候，有一个渐进式思维，擅用算法，逐步优化，我觉得才是异次元方阵的破解之法。
如果您感兴趣的话，也可以去了解<code class="highlighter-rouge">动态规划</code>，<code class="highlighter-rouge">分治</code>，<code class="highlighter-rouge">备忘录</code>，<code class="highlighter-rouge">最大连续子矩阵和</code> 等。我后续也会慢慢去介绍相关的东西。</p>

  </div>
</div>

<!-- <div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2018/07/22/%E6%B5%85%E8%B0%88-Lazy/">
            浅谈 Lazy
            <small>22 Jul 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2018/07/01/promise-is-a-monad/">
            promise is a monad?
            <small>01 Jul 2018</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2018/06/17/webpack-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">
            webpack 源码分析
            <small>17 Jun 2018</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div> -->


<div class="sub_pagination">

  
    <a class="sub_pagination-item newer" href="/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2017/01/09/2016%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/">上一篇&nbsp<i class="fa fa-chain"></i></a>
  
  
    <a class="sub_pagination-item newer" href="/%E6%8A%80%E6%9C%AF%E5%8D%9A%E6%96%87/2016/06/05/GET%E5%92%8CPOST%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E4%B8%8A%E7%9A%84%E5%A4%9A%E6%95%B0%E7%AD%94%E6%A1%88%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84/">GET和POST有什么区别？及为什么网上的多数答案都是错的。&nbsp<i class="fa fa-share"></i></a>
  
</div>


<!-- <div class="comments"> -->
<h2>Comments</h2>



<!-- Comment BEGIN -->
<div id="gitmentContainer"></div>
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
  var gitment = new Gitment({
    owner: 'xiaoDC',
    id: '2016-09-25 00:00:00 +0800',
    repo: 'xiaoDC.github.io',
    oauth: {
      client_id: '180d6605718d1095fd97',
      client_secret: '160e63d30cac752d518dc4eefd5f21c0443230b5',
    },
  });
  gitment.render('gitmentContainer');
</script>

<!-- Comment END -->

      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    <div class="footer">
  <ul>
    <span>友情链接 ⟹&nbsp;&nbsp;</span>
    <li><a href="http://sound2gd.wang">sound2gd</a></li>
    <li><a href="https://wangqiao.me">夜色残阳の杂货铺子</a></li>
  </ul>
  </p></p>
  <p>  Copyright © 2018 - <a href="/">fri3nds</a> - Powered by
    <a href="http://jekyllrb.com/">Jekyll</a>.
    <a href="http://github.com/">Github</a>
  </p>
  <ul>
    <!-- <li><a href="/"><i class="fa fa-twitter fa-2x"></i></a></li> -->
    <li><a href="https://github.com/xiaoDC"><i class="fa fa-github fa-2x"></i></a></li>
    <!-- <li><a href="https://www.linkedin.com/nhome/?trk="><i class="fa fa-linkedin fa-2x"></i></a></li> -->
  </ul>
</div>


    <!-- "The ending isn’t any more important than the moments leading to it." -Dr. Eva Rosalene, To The Moon -->
  </body>
</html>

